#include <stdio.h>
#include <string.h>

#include "{{ fname }}_proto.h"

{%- macro structdef(name, message) %}
static const struct {{ name }} {{ name }}_defaults = {
    {%- for field in message.fields %}
        {%- if field.modifier == 'repeated' %}
    .{{ field.name }} = { 0 }
        {%- elif field.type in ('message', 'bytes') %}
    .{{ field.name }} = NULL
        {%- elif field.type == 'string' %}
    .{{ field.name }} = {{ field.default|default('NULL', true) }}
        {%- else %}
	.{{ field.name }} = {{ field.default|default('0', true) }}
        {%- endif %}
        {%- if not loop.last %},{% endif %}
    {%- endfor %}
};

struct {{ name }} *
{{ name }}_init()
{
    struct {{ name }} *message = malloc(sizeof(struct {{ name }}));

    memcpy(message, &{{ name }}_defaults, sizeof(struct {{ name }}));

    /* Note: lazy init arrays for now */

    return message;
}

void
{{ name }}_destroy(struct {{ name }} *message)
{
    if (message == NULL) {
        return;
    }

    {%- for field in message.fields %}
        {%- if field.modifier == 'repeated' %}
            {%- if field.type == 'message' %}
    {% if field.is_nested %}{{ name }}{% endif %}{{ field.message_name }}_list_destroy(&message->{{ field.name }});
            {%- else %}
    {{ field.list_type }}_destroy(&message->{{ field.name }});
            {%- endif %}
        {%- elif field.type == 'message' %}
    {% if field.is_nested %}{{ name }}{% endif %}{{ field.message_name }}_destroy(message->{{ field.name }});
        {%- elif field.type == 'bytes' %}
    if (message->{{ field.name }} != NULL) {
        free(message->{{ field.name }});
    }
        {%- elif field.type == 'string' %}
    /* yes, pointer comparison */
    if (message->{{ field.name }} != {{ name }}_defaults.{{ field.name }}) {
        free(message->{{ field.name }});
    }
        {%- endif %}
    {%- endfor %}

    free(message);
}

void
{{ name }}_clear(struct {{ name }} *message)
{
    memcpy(message, &{{ name }}_defaults, sizeof(struct {{ name }}));
}

struct {{ name }} *
{{ name }}_copy(struct {{ name }} *message)
{
    struct {{ name }} *out = malloc(sizeof(struct {{ name }}));

    memcpy(out, message, sizeof(struct {{ name }}));

    {%- for field in message.fields %}
        {%- if field.modifier == 'repeated' %}
            {%- if field.type == 'message' %}
    {% if field.is_nested %}{{ name }}{% endif %}{{ field.message_name }}_list_copy(&out->{{ field.name }}, &message->{{ field.name }});
            {%- else %}
    {{ field.list_type }}_copy(&out->{{ field.name }}, &message->{{ field.name }});
            {%- endif %}
        {%- elif field.type == 'message' %}
    out->{{ field.name }} = {% if field.is_nested %}{{ name }}{% endif %}{{ field.message_name }}_copy(message->{{ field.name }});
        {%- endif %}
    {%- endfor %}

    return out;
}

int
{{ name }}_parse_from_string(struct {{ name }} *message,
	const uint8_t *buffer, size_t max_offset, size_t *offset)
{
    int64_t key;
    int64_t field_idx;
    {%- if message.fields|selectattr('type', 'equalto', 'message')|first is defined or
           message.fields|selectattr('type', 'equalto', 'string')|first is defined or
           message.fields|selectattr('type', 'equalto', 'bytes')|first is defined %}
    size_t field_size;
    {%- endif %}

    {%- for field in message.fields|sort(attribute='index') %}
        {%- if field.modifier == 'repeated' and field.packed|default(false) == true %}
    int64_t {{ field.name }}_marker;
        {%- endif %}
        {%- if field.modifier == 'repeated' %}
            {%- if field.type == 'message' %}
    struct {% if field.is_nested %}{{ name }}{% endif %}{{ field.message_name }} *{{ field.name }}_elt;
            {%- elif field.type == 'string' %}
    char *{{ field.name }}_elt;
            {%- elif field.type == 'bytes' %}
    struct cyrobuf_bytes *{{ field.name }}_elt;
            {%- else  %}
    {{ field.c_type }} {{ field.name }}_elt;
            {%- endif %}
        {%- endif %}
    {%- endfor %}

    {% if message.fields|count > 0 %}
    while (*offset < max_offset) {
        key = get_varint64(buffer, offset);
        field_idx = (key >> 3);

        switch (field_idx) {
    {%- for field in message.fields|sort(attribute='index') %}
        /* {{ field.name }} */
        case {{ field.index }}:
        {%- if field.modifier == 'repeated' %}
            {%- if field.packed|default(false) == true %}
            {{ field.name }}_marker = get_varint64(buffer, offset);
            {{ field.name }}_marker += *offset;

            while (*offset < {{ field.name }}_marker) {
                {%- if field.fixed_width == true %}
                {{ field.name }}_elt = *({{ field.c_type }} *)(buffer + *offset);
                *offset += sizeof({{ field.c_type }});
                {%- elif field.var_width == true %}
                {{ field.name }}_elt = {{ field.getter }}(buffer, offset);
                {%- endif %}
                {{ field.list_type }}_append(&message->{{ field.name }}, {{ field.name }}_elt);
            }
            {%- else %}
                {%- if field.type == 'message' %}
            {{ field.name }}_elt = {% if field.is_nested %}{{ name }}{% endif %}{{ field.message_name }}_init();
            field_size = (size_t)get_varint64(buffer, offset);
            {% if field.is_nested %}{{ name }}{% endif %}{{ field.message_name }}_parse_from_string({{ field.name }}_elt, buffer, *offset + field_size, offset);
            {% if field.is_nested %}{{ name }}{% endif %}{{ field.message_name }}_list_append_unsafe(&message->{{ field.name }}, {{ field.name }}_elt);

                {%- elif field.type == 'string' %}
            field_size = (size_t)get_varint64(buffer, offset);
            {{ field.name }}_elt = strndup((char *)(buffer + *offset), field_size);
            cyrobuf_string_list_append_unsafe(&message->{{ field.name }}, {{ field.name }}_elt);
            *offset += field_size;

                {%- elif field.type == 'bytes' %}
            field_size = (size_t)get_varint64(buffer, offset);
            {{ field.name }}_elt = calloc(1, sizeof(struct cyrobuf_bytes) + field_size);
            {{ field.name }}_elt->len = field_size;
            memcpy({{ field.name }}_elt->data, (buffer + *offset), field_size);
            cyrobuf_bytes_list_append_unsafe(&message->{{ field.name }}, {{ field.name }}_elt);
            *offset += field_size;

                {%- elif field.fixed_width == true %}
            {{ field.name }}_elt = *({{ field.c_type }} *)(buffer + *offset);
            {{ field.list_type }}_append(&message->{{ field.name }}, {{ field.name }}_elt);
            *offset += sizeof({{ field.c_type }});

                {%- elif field.var_width == true %}
            {{ field.name }}_elt = {{ field.getter }}(buffer, offset);
            {{ field.list_type }}_append(&message->{{ field.name }}, {{ field.name }}_elt);
                {%- endif %}
            {%- endif %}

        {%- elif field.type == 'message' %}
            if (message->{{ field.name }} == NULL) {
                message->{{ field.name }} = {% if field.is_nested %}{{ name }}{% endif %}{{ field.message_name }}_init();
            }
            field_size = (size_t)get_varint64(buffer, offset);
            {% if field.is_nested %}{{ name }}{% endif %}{{ field.message_name }}_parse_from_string(message->{{ field.name }}, buffer, *offset + field_size, offset);

        {%- elif field.type == 'string' %}
            field_size = (size_t)get_varint64(buffer, offset);
            message->{{ field.name }} = strndup((char *)(buffer + *offset), field_size);
            *offset += field_size;

        {%- elif field.type == 'bytes' %}
            field_size = (size_t)get_varint64(buffer, offset);
            message->{{ field.name }} = calloc(1, sizeof(struct cyrobuf_bytes) + field_size);
            message->{{ field.name }}->len = field_size;
            memcpy(message->{{ field.name }}->data, (buffer + *offset), field_size);
            *offset += field_size;

        {%- elif field.type == 'enum' %}
            message->{{ field.name }} = (enum {% if field.is_nested %}{{ name }}{% endif %}{{ field.enum_name }}){{ field.getter }}(buffer, offset);

        {%- elif field.fixed_width == true %}
            message->{{ field.name }} = *({{ field.c_type }} *)(buffer + *offset);
            *offset += sizeof({{ field.c_type }});

        {%- elif field.var_width == true %}
            message->{{ field.name }} = {{ field.getter }}(buffer, offset);

        {%- endif %}
            break;
    {%- endfor %}
        default:
            return 1;
        }
    }
    {%- endif %}

    return 0;
}

int
{{ name }}_serialize_to_string(struct {{ name }} *message,
	uint8_t *buffer, size_t buffer_size, size_t *used)
{
    return 0;
}

void
{{ name }}_print(struct {{ name }} *message, size_t indent)
{
    char leader[MAX_INDENT] = { 0 };
    indent = indent < MAX_INDENT ? indent : MAX_INDENT - 1;

    for (size_t i = 0; i < indent; i++) {
        leader[i] = '\t';
    }

    printf("%s%s: {\n", leader, "{{ name }}");
    {%- for field in message.fields|sort(attribute='index') %}
    printf("%s\t%s: ", leader, "{{ field.name }}");
        {%- if field.modifier == 'repeated' %}
    printf("[");
    for (size_t i = 0; i < message->{{ field.name }}.len; i++) {
            {%- if field.type == 'message' %}
        printf("\n");
        {% if field.is_nested %}{{ name }}{% endif %}{{ field.message_name }}_print(message->{{ field.name }}.values[i], indent + 2);
            {%- elif field.type != 'bytes' %}
        printf("{{ field.str_format }}", message->{{ field.name }}.values[i]);
            {%- endif %}
        if (i < message->{{ field.name }}.len - 1) {
            printf(", ");
        }
    }
            {%- if field.type == 'message' %}
    printf("\n%s\t]\n", leader);
            {%- else %}
    printf("]\n");
            {%- endif %}
        {%- elif field.type == 'message' %}
    if (message->{{ field.name }} != NULL) {
        printf("\n");
        {% if field.is_nested %}{{ name }}{% endif %}{{ field.message_name }}_print(message->{{ field.name }}, indent + 2);
    } else {
        printf("NULL");
    }
    printf("\n");
        {%- elif field.type == 'string' %}
    if (message->{{ field.name }} != NULL) {
        printf("%s\n", message->{{ field.name }});
    } else {
        printf("NULL\n");
    }
        {%- elif field.type != 'bytes' %}
    printf("{{ field.str_format }}\n", message->{{ field.name }});
        {%- endif %}
    {%- endfor %}
    printf("%s}", leader);
}

void
{{ name }}_list_destroy(struct {{ name }}_list *list)
{
    /* free elements of list but not the list itself */
    for (size_t i = 0; i < list->len; i++) {
        {{ name }}_destroy(list->values[i]);
    }

    free(list->values);

    list->len = 0;
    list->_size = 0;
}

void
{{ name }}_list_copy(struct {{ name }}_list *dest, struct {{ name }}_list *src)
{
    dest->values = realloc(dest->values, src->len * sizeof(struct {{ name }} *));
    dest->len = dest->_size = src->len;

    for (size_t i = 0; i < src->len; i++) {
        dest->values[i] = {{ name }}_copy(src->values[i]);
    }
}

void
{{ name }}_list_append(struct {{ name }}_list *list, struct {{ name }} *message)
{
    if (list->_size <= list->len) {
        list->_size = list->_size > 0 ? list->_size << 1 : 4;
        list->values = realloc(list->values, list->_size * sizeof(struct {{ name }} *));
    }

    list->values[list->len++] = {{ name }}_copy(message);
}

void
{{ name }}_list_append_unsafe(struct {{ name }}_list *list, struct {{ name }} *message)
{
    if (list->_size <= list->len) {
        list->_size = list->_size > 0 ? list->_size << 1 : 4;
        list->values = realloc(list->values, list->_size * sizeof(struct {{ name }} *));
    }

    list->values[list->len++] = message;
}

void
{{ name }}_list_extend(struct {{ name }}_list *list, struct {{ name }}_list *other)
{
    if (list->_size < list->len + other->len) {
        list->_size = list->len + other->len;
        list->values = realloc(list->values, list->_size * sizeof(struct {{ name }} *));
    }

    for (size_t i = 0; i < other->len; i++) {
        list->values[list->len++] = {{ name }}_copy(other->values[i]);
    }
}

void
{{ name }}_list_insert(struct {{ name }}_list *list, int i, struct {{ name }} *message)
{
    if (list->_size <= list->len) {
        list->_size = list->_size > 0 ? list->_size << 1 : 4;
        list->values = realloc(list->values, list->_size * sizeof(struct {{ name }} *));
    }

    for (size_t j = list->len; j > i; j--) {
        list->values[j] = {{ name }}_copy(list->values[j - 1]);
    }

    list->values[i] = message;
    list->len++;
}

struct {{ name }} *
{{ name }}_list_pop(struct {{ name }}_list *list)
{
    return list->values[--list->len];
}

int
{{ name }}_list_remove(struct {{ name }}_list *list, struct {{ name }} *message)
{
    size_t i;

    for (i = 0; i < list->len; i++) {
        if (list->values[i] == message) {
            break;
        }
    }

    if (i == list->len) {
        return 1;
    }

    for (size_t j = i; j < list->len - 1; j++) {
        list->values[j] = list->values[j + 1];
    }

    return 0;
}

	{%- for message_name, message_message in message.messages.items() %}
{{ structdef(name + message_name, message_message) }}
	{%- endfor %}
{%- endmacro %}

{%- for message in messages %}
{{ structdef(message.name, message) }}
{%- endfor %}

